<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Mastering Yarhl | SceneGate Yarhl </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Mastering Yarhl | SceneGate Yarhl ">
    <meta name="generator" content="docfx 2.40.7.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="../fusion/toc.html">
    
    
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="mastering-yarhl">Mastering Yarhl</h1>

<p><img src="../images/logo.png" alt="Yarhl Logo"></p>
<p><strong>Yarhl</strong> - <em>Yet Another ROM Hacking Library</em> - is a library for <em>ROM Hacking</em> and fan-translation projects. It provides a virtual file system, file format, and format conversion features and plugin support.</p>
<p>But what it really has to offer? Why should you use it? And how? This tutorial will teach you how to use Yarhl and how to take advantage of the 100% of it.</p>
<p>Remember that if you have any question you can <a href="https://gitter.im/SceneGate/Yarhl">use our gitter chat</a>, but first make sure you've read the whole docs.</p>
<h2 id="your-first-steps-reading-and-writing">Your first steps: Reading and Writing</h2>
<p>Oh, hi! I'm Master Yarhl (or M.Y.). Nice to meet you. I will be your guide! Erm... y-you can... picture me like this:</p>
<p><img src="../images/mister.png" alt="Master Yarhl"></p>
<p>Let's get started! The first module I'm teaching you is <a class="xref" href="../api/Yarhl.IO.html"><code>Yarhl.IO</code></a> (IO stands for <em>Input/Output</em>), which is similar to .NET standard <code>System.IO</code> but with specific features to work with binary files.</p>
<p>This module is divided into binary and text files. Easy peasy!
Let's go deeper into these classes!</p>
<h3 id="datastream">DataStream</h3>
<p><a class="xref" href="../api/Yarhl.IO.DataStream.html"><code>DataStream</code></a> wraps any kind of .NET <code>Stream</code>.</p>
<h4 id="reuse-of-stream">Reuse of Stream</h4>
<p>It allows to reuse a parent Stream to have substreams to reduce the number of resources to use. For instance, to unpack a file you would just need to create <code>DataStream</code> instances from the same parent <code>DataStream</code> having different offsets and lengths.</p>
<p>Disposing the last instance of a <code>DataStream</code> that has a reference to a <code>Stream</code> will dispose its parent <code>Stream</code> too.</p>
<h4 id="comparison">Comparison</h4>
<p>The <code>DataStream</code> class provides the <a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_Compare_Yarhl_IO_DataStream_"><code>Compare</code></a> method to check if two streams are identical.</p>
<h4 id="push-and-pop-positions">Push and pop positions</h4>
<p>Similar to the terminal commands <code>pushd</code> and <code>popd</code>, our <code>DataStream</code> provides methos to temporarily moving into a position to perform an operation and then restore the position. This is very useful when you need to read or write a few fields into another section of the file. It works with an stack so you can push several positions.</p>
<ul>
<li><a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_PushCurrentPosition"><code>PushCurrentPosition</code></a>: save the current position.</li>
<li><a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_PushToPosition_"><code>PushToPosition</code></a>: save the current position and move.</li>
<li><a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_PopPosition"><code>PopPosition</code></a>: restore the last saved position.</li>
<li><a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_RunInPosition_System_Action_System_Int64_Yarhl_IO_SeekMode_"><code>RunInPosition</code></a>: push, run the lambda expression and pop again.</li>
</ul>
<h4 id="read-and-write">Read and Write</h4>
<p>We have also the typical read and write methods for arrays of bytes. And don't forget about the <a class="xref" href="../api/Yarhl.IO.DataStream.html#Yarhl_IO_DataStream_WriteTo_System_String_"><code>WriteTo</code></a> methods that allows to write a full <code>DataStream</code> into another <code>DataStream</code> or into a file in your HD. Very useful mate!</p>
<h3 id="datareader-and-datawriter">DataReader and DataWriter</h3>
<p><a class="xref" href="../api/Yarhl.IO.DataReader.html"><code>DataReader</code></a> is the equivalent of the .NET <code>BinaryReader</code> and <a class="xref" href="../api/Yarhl.IO.DataWriter.html"><code>DataWriter</code></a> of `BinaryWriter. Apart from the typical read and write methods, they provide the following very useful features.</p>
<h4 id="endianness">Endianness</h4>
<p>By properties or constructor you can specify if the endianness of the stream if little or endian. This will affect to all the read and write operations.</p>
<h4 id="strings">Strings</h4>
<p>By using the different overloads of <code>ReadString</code> and <code>Write</code> you can read and write strings with different encodings, fixed sizes, null terminated or not or in the class <em>size + content</em> style. I recommend you to take a look into them, they cover all the cases you will need to work with files.</p>
<h4 id="padding">Padding</h4>
<p>Are you tired of writing logic to skip or write padding bytes? Well, we too!
If you are reading a file and you want to skip padding bytes, you can call <a class="xref" href="../api/Yarhl.IO.DataReader.html#Yarhl_IO_DataReader_ReadPadding_System_Int32_System_Boolean_"><code>ReadPadding</code></a> and if you need to write padding bytes, then <a class="xref" href="../api/Yarhl.IO.DataWriter.html#Yarhl_IO_DataWriter_WritePadding_System_Byte_System_Int32_System_Boolean_"><code>WritePadding</code></a> will be your friend.</p>
<h3 id="textreader-and-textwriter">TextReader and TextWriter</h3>
<p>So far, <code>DataReader</code> and <code>DataWriter</code> have been very useful when you are dealing with a file that contains some integer fields for size or offset, arrays of bytes and maybe null-terminated strings. But, what about if you need to work with a file that only contains text and you are interested in reading line by line? In that case, you need <a class="xref" href="../api/Yarhl.IO.TextReader.html"><code>TextReader</code></a> and <a class="xref" href="../api/Yarhl.IO.TextWriter.html"><code>TextWriter</code></a>.</p>
<h4 id="new-lines">New lines</h4>
<p>By default, <code>TextWriter</code> uses always (Windows too) the new line <code>\n</code>. It doesn't use <code>\r\n</code>. The reason is that most file formats uses <code>\n</code> and in some games having the <code>\r</code> may crash. It's sometimes difficult to notice that. If you want to use any other new line string (you can even use <code>&lt;br/&gt;</code>), you just need to change the <a class="xref" href="../api/Yarhl.IO.TextWriter.html#Yarhl_IO_TextWriter_NewLine"><code>NewLine</code></a> property.</p>
<p>In the case of the <code>TextReader</code> the behavior is different. The default value for the <a class="xref" href="../api/Yarhl.IO.TextReader.html#Yarhl_IO_TextReader_NewLine"><code>NewLine</code></a> property depends on the OS (Windows: <code>\r\n</code>, Unix: <code>\n</code>). In addition, we provided with an automatic mehcanism enabled by default: <a class="xref" href="../api/Yarhl.IO.TextReader.html#Yarhl_IO_TextReader_AutoNewLine_"><code>AutoNewLine</code></a>. If it's enabled, you don't need to know the line ending in advance because we will stop at <code>\n</code> and remove the last <code>\r</code> if present. This is also useful if a file mix both line endings. And remember, by setting the <code>NewLine</code> property <code>AutoNewLine</code> is disabled.</p>
<h4 id="encoding">Encoding</h4>
<p>The encoding can only by specified in the constructor. We believe that it doesn't have sense to change the encoding once you start using the reader because a text file must not mix encodings.</p>
<h4 id="peeking">Peeking</h4>
<p>Do you need to read a line without actually moving the position of the stream? Maybe you want to check if the line contains a token but you are not sure and don't want to keep the current position all the time. Well, in that case you have the <code>Peek*</code> methods.</p>
<h4 id="preambles--bom">Preambles / BOM</h4>
<p>Some encodings may have a specific <a href="https://en.wikipedia.org/wiki/Byte_order_mark">BOM</a> (<em>Byte Order Mark</em>) (or <em>preamble</em> in the .NET world). These are some bytes at the beginning of the stream that confirms the encoding of the file. For instance, when using UTF-16, the file will begin with the bytes <code>0xFEFF</code>. It also specifies if the encoding is little-ending or big-endian (needed for UTF-16).</p>
<p>Our <code>TextReader</code> will skip the BOM (<em>if it's present</em>) at the beginning of the file. In the case of the <code>TextWriter</code>, the behavior is defined by the property <a class="xref" href="../api/Yarhl.IO.TextWriter.html#Yarhl_IO_TextWriter_AutoPreamble"><code>AutoPreamble</code></a> which is set to <code>false</code> by default (again, some games may see it as unexpected bytes). When enabled, the first write call will also write the BOM. You can also write it manually by calling <a class="xref" href="../api/Yarhl.IO.TextWriter.html#Yarhl_IO_TextWriter_WritePreamble"><code>WritePreamble()</code></a> (but remember, only if you are at the beginning of the stream).</p>
<p>I know... I talk too much... Let's continue!</p>
<h3 id="examples">Examples</h3>
<h4 id="reading--writing-a-binary-file">Reading / writing a binary file</h4>
<pre><code class="lang-csharp">public void LoadFile(string path)
{
    using (var stream = new DataStream(path, FileOpenMode.Read)) {
        var reader = new DataReader(stream) {
            DefaultEncoding = new EscapeOutRangeEnconding(&quot;ascii&quot;),
            Endianness = EndiannessMode.BigEndian,
        };

        string id = reader.ReadString(4);
        int offset = reader.ReadInt32();
        reader.ReadPadding(32);
        double myDouble = reader.ReadDouble();

        string name;
        stream.RunInPosition(
            () =&gt; name = reader.ReadString(),
            offset);
    }
}

public void SaveFile(string path)
{
    using (var stream = new DataStream(path, FileOpenMode.Read)) {
        var writer = new DataWriter(stream);

        writer.Write(&quot;TEX0&quot;, false);
        writer.Write(0xCAFE);
        writer.Write(0x00);
        writer.WritePadding(0xFF, 32);
        writer.Write(&quot;My long text of 80 bytes&quot;, 80);

        stream.PushToPosition(0x08);
        writer.Write(0x65402);
        stream.PopPosition();
    }
}
</code></pre>
<h4 id="reading--writing-a-text-file">Reading / writing a text file</h4>
<pre><code class="lang-csharp">public void LoadFile(DataStream stream)
{
    var reader = new TextReader(stream, Encoding.Unicode);

    string firstLine = reader.ReadLine();
    char[] someChars = reader.Read(4);
    string beforeToken = reader.ReadToToken(&quot;#&quot;);

    if (reader.Peek() == ':')
        reader.ReadLine();
    string restFile = reader.ReadToEnd();
}

public void SaveFile(DataStream stream)
{
    var writer = new TextWriter(stream) {
        AutoPreamble = true,
    };

    writer.WriteLine(&quot;Hello world!&quot;);
    writer.WriteLine(&quot;Count is {0}&quot;, 42);
    writer.Write(&quot;No new line&quot;);
}
</code></pre>
<h2 id="implementing-file-formats">Implementing file formats</h2>
<p>Every game contains many files, which have a specific formats. For example files with extension <code>.nclr</code> are a palettes, or <code>.aar</code> are a package files. Yarhl helps you to code type as you were actually coding a game format.</p>
<p>To implement a file format, you just need to create a new class that inherits from the <a class="xref" href="../api/Yarhl.FileFormat.Format.html"><code>Format</code></a> class. In this class you just need to add the fields of your format. In more programming terms, your format it's just a data model.</p>
<p>Let's go for a quick example! Take a look into the following bytes from a file that seems to have text from a game menu:</p>
<p><img src="../images/hex_example.png" alt="Hex view of example file"></p>
<p>This file seems to follow the following specification in little endian:</p>
<table>
<thead>
<tr>
<th>Size</th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>Magic ID</td>
</tr>
<tr>
<td>2</td>
<td>Number of sentences</td>
</tr>
<tr>
<td>2</td>
<td>Size of the file</td>
</tr>
<tr>
<td>*</td>
<td>Null-terminated sentences</td>
</tr>
</tbody>
</table>
<p>So given this format, we would implement the following class that maps the specification:</p>
<pre><code class="lang-csharp">public class MenuSentences : Format
{
    public uint MagicID { get; set; }
    public ushort FileSize { get; set; }
    public IList&lt;String&gt; Sentences { get; private set; }

    public MenuSentences()
    {
        Sentences = new List&lt;String&gt;();
    }
}
</code></pre>
<p>Easy! Don't worry about how to convert that format, we will talk about that later.</p>
<h3 id="binaryformat">BinaryFormat</h3>
<p><a class="xref" href="../api/Yarhl.FileFormat.BinaryFormat.html"><code>BinaryFormat</code></a> is the most basic format since it just represents raw bytes, a stream. It's... a <em>binary format</em>. This format is assigned automatically when we open a file from Yarhl as we will see later.</p>
<p>Its only property <a class="xref" href="../api/Yarhl.FileFormat.BinaryFormat.html#Yarhl_FileFormat_BinaryFormat_Stream_"><code>Stream</code></a> allows you to access to its inner stream.</p>
<h3 id="nodecontainerformat">NodeContainerFormat</h3>
<p>You may wonder... what about package formats like <code>.zip</code>? They are represented with the format (or by inheriting it) <a class="xref" href="../api/Yarhl.FileSystem.NodeContainerFormat.html"><code>NodeContainerFormat</code></a>. This format contains a root folder, also known as <code>Node</code>. So let's see what a <code>Node</code> is.</p>
<h2 id="entering-the-virtual-world-nodes">Entering the virtual world: Nodes</h2>
<p>This is the main feature of Yarhl and the most important one, no doubt, 10/10 Yarhl users would say so<sup>1</sup>. Yarhl has a virtual file system to handle your files while mantaining your computer intact, you can now delete your &quot;tests&quot; folder and clean your desktop after-ages.</p>
<p><sup>1</sup> <small>None of Yarhl users wants to talk with me anymore. This may not be 100% accurate.</small></p>
<h3 id="nodes">Nodes</h3>
<p>A <a class="xref" href="../api/Yarhl.FileSystem.Node.html"><code>Node</code></a> is a virtual file. It's like having a file system with files and folder but only in memory for the duration of your program. You can dynamically add and remove files / folders. These files and folders are called nodes in Yarhl.</p>
<p>A node may have child nodes like a folder may have folders and files. You can add the <em>subnodes</em> with the <a href="xref:Yarhl.FileSystem.NavigableNode%7BYarhl.FileSystem.Node%7D.Add(Yarhl.FileSystem.Node)"><code>Add</code></a> method and you iterate and access to its children with the <a href="xref:Yarhl.FileSystem.NavigableNode%7BYarhl.FileSystem.Node%7D.Children"><code>Children</code></a> property.</p>
<p>The node <a href="xref:Yarhl.FileSystem.NavigableNode%7BYarhl.FileSystem.Node%7D.Name"><code>Name</code></a> must be unique. You can also get the full path to the node in this new virtual filesystem. That is, if you have a <em>root</em> node with name <code>MyRoot</code> and you add a node <code>Node1</code>, the <a href="xref:Yarhl.FileSystem.NavigableNode%7BYarhl.FileSystem.Node%7D.Path"><code>Path</code></a> property for <code>Node1</code> will be <code>/MyRoot/Node1</code>.</p>
<p>Ah, one more thing before I forget. Regular files in your disk have some bytes associated, right? Well, in the case of nodes they have a <a href="#implementing-file-formats">Format</a> that we were talking before. That is, it doesn't have to have bytes but it could be a type to represent image, texture, text, font, ... The actual type of the node.
For instance, let's say we create a node from a disk file, it will have a <code>BinaryFormat</code> because for now it's just a bunch of bytes. But if those bytes store a set of menu texts, we could transform its format and associate its actual content type: <code>MenuSentences</code>. To the node <a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_Format_"><code>Format</code></a> property you can set any type that inhertis the <a class="xref" href="../api/Yarhl.FileFormat.Format.html"><code>Format</code></a> class.</p>
<p>By the way, there is a property to get the inner <code>DataStream</code> when the format of the node is a <code>BinaryFormat</code>: <a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_Stream"><code>Stream</code></a>. It will return <code>null</code> if the type is not <code>BinaryFormat</code>. We added it because to do cool things like:</p>
<pre><code class="lang-csharp">node.Stream.WriteTo(&quot;/home/master_yarhl/my_node.bin&quot;);
</code></pre>
<p>If the type is different, you may want to check the method <a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_GetFormatAs__1"><code>GetFormatAs&lt;T&gt;()</code></a>.</p>
<h3 id="why-nodes">Why nodes?</h3>
<p>Well, imagine that you have a Nintendo DS game <code>.nds</code>, you could open it with Yarhl and access to its files and folders without actually extraing the files into your disk. All access would be in memory, probably even sharing the same stream thanks to the <code>sub-DataStreams</code>.</p>
<h3 id="files-vs-folders">Files vs folders</h3>
<p>As said, folders in our virtual file system are also nodes. They always have the <code>NodeContainerFormat</code> or any class that inherits it. This format is just a root node folder that becomes the children of the node. You can use the property <a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_IsContainer_"><code>IsContainer</code></a> to check if the node is a node container, that is, if it's a folder.</p>
<p>It's more clear with a picture:</p>
<p><img src="../images/node_example.png" alt="A directory named mastering with tho files inside"></p>
<p><code>mastering</code> would be our root node with format <code>NodeContainerFormat</code>. While <code>example.example</code> and <code>example2.example</code> would be our two child nodes. By default they will have a <code>BinaryFormat</code> format.</p>
<h3 id="navigating-the-sea-of-nodes">Navigating the sea of nodes</h3>
<p>Do you have many nodes? I guess it will be difficult to navigate through all of them. Then, you want to review the class <a class="xref" href="../api/Yarhl.FileSystem.Navigator.html"><code>Navigator</code></a>. It provides with features like iterators and finders.</p>
<p>To iterate over the node children you would just do:</p>
<pre><code class="lang-csharp">foreach (var node in root.Children) {
    // Something
}
</code></pre>
<p>But if you want to iterate over the full tree of nodes, that is, including the children of your childrens (like <code>node</code> in the above example), you can use the <code>Navigator</code>.</p>
<pre><code class="lang-csharp">foreach (var node in Navigator.IterateNodes(root)) {
    // Something
}
</code></pre>
<p>You can even specify how to do the iteration: going first deeper into each node (<a href="https://en.wikipedia.org/wiki/Depth-first_search"><em>depth-first search</em></a>) or getting first every children from the current node (<a href="https://en.wikipedia.org/wiki/Breadth-first_search"><em>breadth-first search</em></a>).</p>
<p>If you just want to search a specific node given a full path, you want to use <a class="xref" href="../api/Yarhl.FileSystem.Navigator.html#Yarhl_FileSystem_Navigator_SearchNode__1___0_System_String_"><code>Navigator.SearchNode(path)</code></a>.</p>
<h3 id="creating-the-file-system">Creating the file system</h3>
<p>So you want to start using node right now, eh. Well, it will be easy. You will want to check out the static helper class: <a class="xref" href="../api/Yarhl.FileSystem.NodeFactory.html"><code>NodeFactory</code></a>. Let's check some of its methods:</p>
<pre><code class="lang-csharp">// Manual
var node1 = new Node(&quot;name&quot;, new BinaryFormat(filePath));

// Factory
var node2 = NodeFactory.FromFile(filePath);  // Node name is the file name
</code></pre>
<p>So, what about creating a node from a folder you would say.</p>
<pre><code class="lang-csharp">var emptyFolder = NodeFactory.CreateContainer(&quot;name&quot;);

var folderFromDisk = NodeFactory.FromDirectory(folderPath);
</code></pre>
<p>Yeeeah! That's the face I was looking for! You can create a virtual file that quick!</p>
<p>Don't forget to review the overloads and the method <a class="xref" href="../api/Yarhl.FileSystem.NodeFactory.html#Yarhl_FileSystem_NodeFactory_FromMemory_System_String_"><code>FromMemory</code></a> to create a node from a new <code>MemoryStream</code>.</p>
<p>Yarhl is way more interesting now, right!?</p>
<h2 id="converters-putting-together-all-the-pieces">Converters: putting together all the pieces</h2>
<p>Finally! We have <em>formats</em>, <em>nodes</em> and some classes for <em>IO</em> operations. Now everything begin to fall into place, you'll see.</p>
<p>Creating a tool to work with files usually require to work with different formats, right? We need to convert from <code>.dat</code> to <code>.txt</code>, from <code>.bin</code> into a a palette or unpacking several files from a <code>.pak</code> file.</p>
<p>Well, that's easy to do. Yarhl is all about converting formats, let's see an example:</p>
<pre><code class="lang-csharp">public void ExportFontImage(string fontPath, string outputPath)
{
    using (var binary = new BinaryFormat(fontPath)) {
        binary.ConvertWith&lt;Font2Binary, BinaryFormat, Font&gt;()
            .ConvertWith&lt;Font2Image, Font, System.Drawing.Image&gt;()
            .Save(outputPath);
    }
}
</code></pre>
<ol>
<li>We start creating a new <code>BinaryFormat</code> from a file path.</li>
<li>We convert the <code>BinaryFormat</code> (reading its <code>Stream</code>) into a <code>Font</code> type.</li>
<li>We convert the <code>Font</code> format into an <code>Image</code> type.</li>
<li>We save it to a physical file in the hard-drive.</li>
</ol>
<p><em>&quot;But what's <code>Font2Binary</code> and <code>Font2Image</code>, <strong>Master Yarhl</strong>?&quot;</em>, you would say.
They are <strong>converters</strong>! A converter is a class which implements the <a class="xref" href="../api/Yarhl.FileFormat.IConverter-2.html">IConverter</a> interface.</p>
<p>You can check some converter examples from the tools to translate <em>Pokémon Conquest</em>. For instance: <a href="https://github.com/pleonex/PokemonConquest/blob/master/AmbitionConquest/AmbitionConquest/Fonts/Font2Binary.cs">Font2Binary</a> and <a href="https://github.com/pleonex/PokemonConquest/blob/master/AmbitionConquest/AmbitionConquest/Fonts/Font2Image.cs">Font2Image</a>.</p>
<h3 id="converting-formats">Converting formats</h3>
<p>But let's come back to our example of <code>MenuSentences</code> from the <a href="#implementing-file-formats">format</a> section. It's turn to create a converter to fill the <code>MenuSentences</code> class from a file. That it's to <em>read</em> a file with that format.</p>
<pre><code class="lang-csharp">public class Binary2MenuSentences : IConverter&lt;BinaryFormat, MenuSentences&gt;
{
    public MenuSentences Convert(BinaryFormat source)
    {
        var menu = new MenuSentences();
        var reader = new DataReader(source.Stream);

        menu.MagicID = reader.ReadUInt32();
        ushort numSentences = reader.ReadUInt16();
        menu.FileSize = reader.ReadUInt16();

        for (int i = 0; i &lt; numSentences; i++) {
            menu.Sentences.Add(reader.ReadString());
        }

        return menu;
    }
}
</code></pre>
<p>So now we can get our menu instance with:</p>
<pre><code class="lang-csharp">public void ReadMenuFile(string filePath)
{
    using (var binary = new BinaryFormat(filePath)) {
        MenuSentences menu = binary
            .ConvertWith&lt;Binary2MenuSentences, BinaryFormat, MenuSentences&gt;();
        // Do something with the menu instance
    }
}
</code></pre>
<p>Since there is just one converter <code>BinaryFormat -&gt; MenuSentences</code> we can simplify it even more:</p>
<pre><code class="lang-csharp">public void ReadMenuFile(string filePath)
{
    using (var binary = new BinaryFormat(filePath)) {
        MenuSentences menu = binary.ConvertTo&lt;MenuSentences&gt;();
        // Do something with the menu instance
    }
}
</code></pre>
<p>Do you want to write your <em>new</em> or <em>updated</em> menu instance? Let's write a converter to convert from <code>MenuSentences</code> to <code>BinaryFormat</code> and save in a file in disk.</p>
<pre><code class="lang-csharp">public class MenuSentences2Binary : IConverter&lt;MenuSentences, BinaryFormat&gt;
{
    public BinaryFormat Convert(MenuSentences menu)
    {
        var binary = new BinaryFormat();
        var writer = new DataWriter(binary.Stream);

        writer.Write(menu.MagicID);
        writer.Write((ushort)menu.Sentences.Count);
        writer.Write((ushort)0x00); // Placeholder size to override later

        foreach (string sentence in menu.Sentences) {
            writer.Write(sentence);
        }

        binary.Stream.Position = 0x06;
        writer.Write((ushort)binary.Stream.Length);

        return binary;
    }
}
</code></pre>
<p>And that's it! I'm pretty sure you've got enough of converters</p>
<h3 id="transforming-nodes">Transforming nodes</h3>
<p>Don't format that a node can have a format. How do we <em>convert</em> the format from a node? We could use the approach from before, but there is a method that will <strong>convert and update</strong> the format of the node: <a class="xref" href="../api/Yarhl.FileSystem.Node.html#Yarhl_FileSystem_Node_Transform_"><code>Transform</code></a>. It will also dispose the old format so we don't need to do anything, just transform several times the format of our node until it's the one we want.</p>
<pre><code class="lang-csharp">var node = NodeFactory.FromFile(path);
node.Transform&lt;MenuSentences&gt;;

// Now node.Format is MenuSentences
</code></pre>
<p>or from the first example:</p>
<pre><code class="lang-csharp">public void ExportFontImage(string fontPath, string outputPath)
{
    using (var node = NodeFactory.FromFile(fontPath)) {
        node.Transform&lt;Font2Binary, BinaryFormat, Font&gt;()
            .Transform&lt;Font2Image, Font, Image&gt;();

        node.GetFormatAs&lt;Image&gt;().Save(outputPath);
    }
}

</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/SceneGate/Yarhl/blob/master/docs/articles/Mastering-Yarhl.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright (c) 2018 SceneGate Team
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
